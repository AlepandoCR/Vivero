<!DOCTYPE html>
<html lang="en">
  <head>
    <style type="text/css">
      .vivero{
        size:1000px;
      }
      .view-button {
          background: rgb(8, 8, 92);
          border: 3px solid rgb(228, 228, 164);
          border-radius: 100px;
          box-shadow: 0 2px 2px rgba(100, 100, 100, 0.25);
          color: rgba(0, 0, 0, 0.8);
          display: block;
          font-family: Futura, Helvetica Neue, sans-serif;
          font-size: 12px;
          font-weight: 700;
          max-width: 128px;
          overflow-wrap: break-word;
          padding: 0.5em 1em;
          position: absolute;
          width: max-content;
          height: max-content;
          transform: translate3d(-50%, -50%, 0);
        }
    </style>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Vivero Virutal</title>
    <meta http-equiv="content-type" content="text/html;charset=utf-8" />
    <meta name="generator" content="Geany 1.37.1" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    
    
    <link href="style.css" rel="stylesheet">
    <!-- The following libraries and polyfills are recommended to maximize browser support -->
      <!-- NOTE: you must adjust the paths as appropriate for your project -->
      
      <!--  REQUIRED: Web Components polyfill to support Edge and Firefox < 63 -->
      <script src="https://unpkg.com/@webcomponents/webcomponentsjs@2.1.3/webcomponents-loader.js"></script> 

      <!--  OPTIONAL: Intersection Observer polyfill for better performance in Safari and IE11 -->
    <script src="https://unpkg.com/intersection-observer@0.5.1/intersection-observer.js"></script>

      <!--  OPTIONAL: Resize Observer polyfill improves resize behavior in non-Chrome browsers -->
    <script src="https://unpkg.com/resize-observer-polyfill@1.5.0/dist/ResizeObserver.js"></script>
      
      <!--  OPTIONAL: The :focus-visible polyfill removes the focus ring for some input types -->
    <!--
    <script src="https://unpkg.com/focus-visible@5.0.2/dist/focus-visible.js" defer></script
    -->
  </head>
  <body>
    <!-- 💁 Include both scripts below to support all browsers! -->

      <!-- Loads <model-viewer> for modern browsers: -->
        <script type="module"
          src="https://unpkg.com/@google/model-viewer/dist/model-viewer.min.js">
        </script>

      <!-- Loads <model-viewer> for old browsers like IE11: -->
        <script nomodule
          src="https://unpkg.com/@google/model-viewer/dist/model-viewer-legacy.js">
        </script>
    <!-- 3D content for your site: -->
      <div class="Barra">
        <center>
          <br>
          <h1>Menu</h1>
        </center>
      </div>

      <div class="vivero">
        <model-viewer id="hotspot-camera-view-demo" camera-controls touch-action="none" camera-orbit="-8.142746deg 68.967deg 0.6179899m" interpolation-decay="200" min-camera-orbit="auto auto 10%" ar ar-modes="webxr scene-viewer quick-look" oncontextmenu="return false;" camera-taget="-0.003m 0.0722m 0.0391m" min-field-of-view="45deg" src="scene.gltf" alt="Vivero">
          <button class="view-button" slot="hotspot-0" data-position="3m 1m -2m" data-normal="0m 0m 0m" data-orbit="-50.94862deg 84.56856deg 0.06545582m" data-target="3m 1m -2m">
            🌱
          </button>
        </model-viewer>
      </div>
      <script type="module">
        const modelViewer = document.querySelector("model-viewer");
        const tapDistance = 2;
        let panning = false;
        let panX, panY;
        let startX, startY;
        let lastX, lastY;
        let metersPerPixel;
      
        const startPan = () => {
          const orbit = modelViewer.getCameraOrbit();
          const {theta, phi, radius} = orbit;
          const psi = theta - modelViewer.turntableRotation;
          metersPerPixel = 0.75 * radius / modelViewer.getBoundingClientRect().height;
          panX = [-Math.cos(psi), 0, Math.sin(psi)];
          panY = [
            -Math.cos(phi) * Math.sin(psi),
            Math.sin(phi),
            -Math.cos(phi) * Math.cos(psi)
          ];
          modelViewer.interactionPrompt = 'none';
        };
      
        const stopPan = (event) => {
          panning = false;
        }
      
        const movePan = (thisX, thisY) => {
          const dx = (thisX - lastX) * metersPerPixel;
          const dy = (thisY - lastY) * metersPerPixel;
          lastX = thisX;
          lastY = thisY;
      
          const target = modelViewer.getCameraTarget();
          target.x += dx * panX[0] + dy * panY[0];
          target.y += dx * panX[1] + dy * panY[1];
          target.z += dx * panX[2] + dy * panY[2];
          modelViewer.cameraTarget = `${target.x}m ${target.y}m ${target.z}m`;
      
          // This pauses turntable rotation
          modelViewer.dispatchEvent(new CustomEvent(
                'camera-change', {detail: {source: 'user-interaction'}}));
        };
      
        const recenter = (pointer) => {
          panning = false;
          if (Math.abs(pointer.clientX - startX) > tapDistance ||
              Math.abs(pointer.clientY - startY) > tapDistance)
            return;
          const hit = modelViewer.positionAndNormalFromPoint(pointer.clientX, pointer.clientY);
          if(hit != null) {
            modelViewer.cameraTarget = hit.position.toString();
          }
          else {
            modelViewer.cameraTarget = 'auto auto auto';
            modelViewer.cameraOrbit = 'auto auto auto';
          }
        };
      
        modelViewer.addEventListener('mousedown', (event) => {
          startX = event.clientX;
          startY = event.clientY;
          panning = event.button === 2 || event.ctrlKey || event.metaKey ||
              event.shiftKey;
          if (!panning)
            return;
      
          lastX = startX;
          lastY = startY;
          startPan();
          event.stopPropagation();
        }, true);
      
        modelViewer.addEventListener('touchstart', (event) => {
          const {targetTouches, touches} = event;
          startX = targetTouches[0].clientX;
          startY = targetTouches[0].clientY;
          panning = targetTouches.length === 2 && targetTouches.length === touches.length;
          if (!panning)
            return;
      
          lastX = 0.5 * (targetTouches[0].clientX + targetTouches[1].clientX);
          lastY = 0.5 * (targetTouches[0].clientY + targetTouches[1].clientY);
          startPan();
        }, true);
      
        self.addEventListener('mousemove', (event) => {
          if (!panning)
            return;
      
          movePan(event.clientX, event.clientY);
          event.stopPropagation();
        }, true);
      
        modelViewer.addEventListener('touchmove', (event) => {
          if (!panning || event.targetTouches.length !== 2)
            return;
      
          const {targetTouches} = event;
          const thisX = 0.5 * (targetTouches[0].clientX + targetTouches[1].clientX);
          const thisY = 0.5 * (targetTouches[0].clientY + targetTouches[1].clientY);
          movePan(thisX, thisY);
        }, true);
      
        let lastMousedown = {time: new Date().getTime()};
        let lastTouchstart = {time: new Date().getTime()};
        function doubletap(timer) {
          var now = new Date().getTime();
          var timesince = now - timer.time;
          timer.time = new Date().getTime();
          if((timesince < 400) && (timesince > 0))
            return true;
          else
            return false;
        }
      
        self.addEventListener('mouseup', (event) => {
          stopPan(event);
        }, true);
      
        modelViewer.addEventListener('oncontextmenu', (event) => {
            return false;
        });
      
        self.addEventListener('mousedown', (event) => {
          if(doubletap(lastMousedown))
              recenter(event);
        }, true);
        
        modelViewer.addEventListener('touchstart', (event) => {
          if (doubletap(lastTouchstart) && event.targetTouches.length === 0) {
            recenter(event.changedTouches[0]);
      
            if (event.cancelable) {
              event.preventDefault();
            }
          }
        }, true);
      </script>
  </body>
</html>
